import { createHash } from "node:crypto";
import { accessSync, constants, existsSync, readFileSync, statSync } from "node:fs";
import { readFile } from "node:fs/promises";
import { join } from "node:path/posix";
import { transform, transformSync } from "esbuild";
import { resolveNodeImport } from "../node.js";
import { resolveNpmImport } from "../npm.js";
import { resolvePath } from "../path.js";
import { builtins } from "../resolvers.js";
import { findFiles } from "./files.js";
import { findImports, parseImports } from "./imports.js";
import { parseProgram } from "./parse.js";
const fileInfoCache = /* @__PURE__ */ new Map();
const moduleInfoCache = /* @__PURE__ */ new Map();
function getModuleHash(root, path) {
  return getModuleHashInternal(root, path).digest("hex");
}
function getModuleHashInternal(root, path) {
  const hash = createHash("sha256");
  const paths = /* @__PURE__ */ new Set([path]);
  for (const path2 of paths) {
    if (path2.endsWith(".js")) {
      const info = getModuleInfo(root, path2);
      if (!info)
        continue;
      hash.update(info.hash);
      for (const i of info.localStaticImports) {
        paths.add(resolvePath(path2, i));
      }
      for (const i of info.localDynamicImports) {
        paths.add(resolvePath(path2, i));
      }
      for (const i of info.files) {
        const f = getFileInfo(root, resolvePath(path2, i));
        if (!f)
          continue;
        hash.update(f.hash);
      }
    } else {
      const info = getFileInfo(root, path2);
      if (!info)
        continue;
      hash.update(info.hash);
    }
  }
  return hash;
}
async function getLocalModuleHash(root, path) {
  const hash = getModuleHashInternal(root, path);
  const info = getModuleInfo(root, path);
  if (info) {
    const globalPaths = /* @__PURE__ */ new Set();
    for (const i of [...info.globalStaticImports, ...info.globalDynamicImports]) {
      if (i.startsWith("npm:") && !builtins.has(i)) {
        globalPaths.add(await resolveNpmImport(root, i.slice("npm:".length)));
      } else if (!/^\w+:/.test(i)) {
        globalPaths.add(await resolveNodeImport(root, i));
      }
    }
    for (const p of globalPaths) {
      hash.update(p);
      for (const i of await parseImports(join(root, ".observablehq", "cache"), p)) {
        if (i.type === "local") {
          globalPaths.add(resolvePath(p, i.name));
        }
      }
    }
  }
  return hash.digest("hex");
}
function getModuleInfo(root, path) {
  const key = join(root, path);
  let mtimeMs;
  try {
    ({ mtimeMs } = statSync(resolveJsx(key) ?? key));
  } catch {
    moduleInfoCache.delete(key);
    return;
  }
  let info = moduleInfoCache.get(key);
  if (!info || info.mtimeMs < mtimeMs) {
    let source;
    let body;
    try {
      source = readJavaScriptSync(key);
      body = parseProgram(source);
    } catch {
      moduleInfoCache.delete(key);
      return;
    }
    const hash = createHash("sha256").update(source).digest("hex");
    const imports = findImports(body, path, source);
    const files = findFiles(body, path, source);
    const localStaticImports = /* @__PURE__ */ new Set();
    const localDynamicImports = /* @__PURE__ */ new Set();
    const globalStaticImports = /* @__PURE__ */ new Set();
    const globalDynamicImports = /* @__PURE__ */ new Set();
    for (const i of imports) {
      (i.type === "local" ? i.method === "static" ? localStaticImports : localDynamicImports : i.method === "static" ? globalStaticImports : globalDynamicImports).add(i.name);
    }
    moduleInfoCache.set(
      key,
      info = {
        mtimeMs,
        hash,
        files: new Set(files.map((f) => f.name)),
        fileMethods: new Set(files.map((f) => f.method).filter((m) => m !== void 0)),
        localStaticImports,
        localDynamicImports,
        globalStaticImports,
        globalDynamicImports
      }
    );
  }
  return info;
}
function getFileHash(root, path) {
  return getFileInfo(root, path)?.hash ?? createHash("sha256").digest("hex");
}
function getFileInfo(root, path) {
  const key = join(root, path);
  let mtimeMs;
  try {
    const stat = statSync(key);
    if (!stat.isFile())
      return;
    accessSync(key, constants.R_OK);
    ({ mtimeMs } = stat);
  } catch {
    fileInfoCache.delete(key);
    return;
  }
  let entry = fileInfoCache.get(key);
  if (!entry || entry.mtimeMs < mtimeMs) {
    const contents = readFileSync(key);
    const hash = createHash("sha256").update(contents).digest("hex");
    fileInfoCache.set(key, entry = { mtimeMs, hash });
  }
  return entry;
}
function resolveJsx(path) {
  return !existsSync(path) && path.endsWith(".js") && existsSync(path += "x") ? path : null;
}
async function readJavaScript(path) {
  const jsxPath = resolveJsx(path);
  if (jsxPath !== null) {
    const source = await readFile(jsxPath, "utf-8");
    const { code } = await transform(source, {
      loader: "jsx",
      jsx: "automatic",
      jsxImportSource: "npm:react",
      sourcefile: jsxPath
    });
    return code;
  }
  return await readFile(path, "utf-8");
}
function readJavaScriptSync(path) {
  const jsxPath = resolveJsx(path);
  if (jsxPath !== null) {
    const source = readFileSync(jsxPath, "utf-8");
    const { code } = transformSync(source, {
      loader: "jsx",
      jsx: "automatic",
      jsxImportSource: "npm:react",
      sourcefile: jsxPath
    });
    return code;
  }
  return readFileSync(path, "utf-8");
}
export {
  getFileHash,
  getFileInfo,
  getLocalModuleHash,
  getModuleHash,
  getModuleInfo,
  readJavaScript,
  readJavaScriptSync
};
