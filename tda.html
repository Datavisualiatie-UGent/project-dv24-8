<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <style>
      .tooltip-item {
        display: flex;
        align-items: center;
        margin-top: 5px;
      }

      .tooltip-color {
        width: 8px;
        height: 8px;
        margin-right: 5px;
      }

      .tooltip {
        position: absolute;
        background-color: rgb(186, 34, 34);
        border: 1px solid #ccc;
        padding: 10px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        font-size: 12px;
        color: #333;
        visibility: hidden;
      }

      #selectrank-container {
        display: none;
      }

      #selectlogbase-container {
        display: none;
      }

      #select-ms2rescore-method-container {
        display: none;
      }

      select {
        width: 60%;
        padding: 4px 4px;
        border-radius: 4px;
        background-color: #f1f1f1;
        text-align: center;
      }

      .flexcontainer {
        background-color: #ffffff;
        display: flex; 
        flex-wrap: wrap;
        border-radius: 10px; 
        padding: 10px;
        margin-left: 40px;
        margin-bottom: 4px;
        margin-right: 40px;
        margin-top: 4px;
        opacity: 0.8;
        border-color: #131d01;
        border-width: 0px;
        width: 100%;
        border-style: solid;
        align-content: center;
      }

      .flexcolumn {
        background-color: #c0c0c0; 
        display: flex; 
        flex-wrap: wrap;
        border-radius: 10px; 
        padding: 10px;
        padding-top: 10px ;
        margin-left: 4px;
        margin-bottom: 4px;
        margin-right: 4px;
        margin-top: 4px;
      }     
      .inputbox {
        background-color: #f0f0f0; 
        width: 100%;
        border-radius: 10px; 
        padding: 10px;
        margin-left:2px;
        margin-bottom: 2px;
        margin-right: 2px;
        margin-top: 2px;
      }
      .subchart{
        background-color: #f0f0f0; 
        width: 100%;
        padding: 10px;
        margin-left:2px;
        margin-bottom: 2px;
        margin-right: 2px;
        margin-top: 2px;        
      }

    </style>

    <title>CAMPI3 datavisualisatie</title>

    <script type="text/javascript" src="./d3.v5.js"></script>
    <link rel="stylesheet" href="jl.css">
    <link href="./node_modules/nouislider/dist/nouislider.css" rel="stylesheet">
    <script src="./node_modules/nouislider/dist/nouislider.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js" charset="utf-8"></script>

  </head>

  <body>
    <header>
      <a href="#"><img src="" alt="" width="20%" height="90" id="Insert_logo" style="background-color: #C6D580; display:block;" /></a>
    </header>

    <div class="container">
      <div class="sidebar1">
        <ul class="nav">
          <li><a href="./index.html">Infopagina</a></li>
          <li><a href="./upset.html">UpSet plots</a></li>
          <li><a href="./barplot_nr_of_mpsms.html">Barplots # mPSMs</a></li>
          <li><a href="./compare_msamanda.html">Comparison MSAmanda</a></li>
          <li><a href="./compare_ms2rescore.html">Comparison MS²Rescore</a></li>
          <li><a href="./tda.html">TDA: Histogram & PP plots</a></li>
          <!-- <li><a href="./histogram.html">TDA: distributies</a></li>   
          <li><a href="./pp_plots.html">TDA: PP plots</a></li> -->
          <!-- <li><a href="./taxonomic_distribution.html">Taxonomic distribution</a></li>
          <li><a href="./sample_composition_charts_v3.html">sample composition</a></li>             
          <li><a href="#">MS²Rescore fts PCA</a></li>
          <li><a href="#">MS²Rescore fts boxplots</a></li> -->
        </ul>
        <aside>
          <p> The above links demonstrate a basic navigational structure using an unordered list styled with CSS. Use this as a starting point and modify the properties to produce your own unique look. If you require flyout menus, create your own using a Spry menu, a menu widget from Adobe's Exchange or a variety of other javascript or CSS solutions.</p>
          <p>If you would like the navigation along the top, simply move the ul to the top of the page and recreate the styling.</p>
        </aside>
      </div>

      <article class="content">
      
        <section style="width: 80%">
          <h2>Histogram</h2>

          <form  class="flexcontainer">
            <div  id="metadata" class="flexcolumn" style="width: 25%;">
              <div class="inputbox" style="width: 100%;">
                <label for="sample">sample: &nbsp;</label>
                <select id="sample" name="sample"  style="width: 60px; ">
                  <option value="F01">F01</option>
                  <option value="F06">F06</option>
                  <option value="F07">F07</option>
                  <option value="S03">S03</option>
                  <option value="S05">S05</option>
                  <option value="S07">S07</option>
                  <option value="S08">S08</option>
                  <option value="S11">S11</option>
                </select>
              </div>
              <div class="inputbox" style="width: 100%;">
                <input type="checkbox" id="scoring" value="true" onclick="toggleSelectScoring()">
                <label for="scoring">MS²Rescore</label>
              </div>

              <div id="select-msamanda-method-container"  class="inputbox" style="width: 100%;">
                  <label for="msamandaMethod">Method: &nbsp;</label>
                  <select name="msamanda" id="msamandaMethod" style="width: 80px; " >
                      <option value='first' selected="selected">first</option>
                      <option value='second'>second</option>
                      <option value='all'>all</option>
                      <option value='one_prec'>max 1 prec</option>
                      <option value='two_prec'>max 2 prec</option>
                  </select>
              </div>

              <div id="select-ms2rescore-method-container"  class="inputbox" style="width: 100%;">
                  <label for="ms2rescoreMethod">Method: &nbsp;</label>
                  <select name="ms2rescore-method" id="ms2rescoreMethod" style="width: 90px; ">
                      <option value='first' selected="selected">first</option>
                      <option value='second'>second</option>
                      <option value='all'>all</option>
                      <option value='merged'>merged</option>
                  </select>
              </div>
            </div>
            
            <div id="data-processing" class="flexcolumn" style="width: 30%;">

              <div aria-label="rank-input" class="inputbox" style="width: calc(100% - 20px);">
                  <label for="selectrank">Select rank: &nbsp;</label>
                  <select name="selectrank" id="selectrank" style="width: 120px;">
                      <option value='rank1'>Rank 1 PSMs</option>
                      <option value='allranks'>All PSMs</option>
                  </select>
              </div>
              <div class="inputbox">
                <div>
                  <input type="checkbox" id="logtransform" value="true" onclick="toggleSelectBase()">
                  <label for="logtransform">Log-transform</label>
                </div>              
                <div id="selectlogbase-container">
                  <label for="logbase">Base: &nbsp;</label>
                  <select name="selectbase" id="logbase">
                      <option value=2 selected="selected">2</option>
                      <option value=10>10</option>
                  </select>
                </div>
              </div>
            </div>

            <div aria-label="layout-input" class="flexcolumn" style="width: 30%">
                
              <div class="inputbox">
                <label for="nr_of_bins">Number of bins</label>
                <input type="number" id="nr_of_bins" name="quantity" min="10" max="500" value="300">
              </div>
                              
              <div class="inputbox">
                <label for="binsize">Size of bins:</label>
                <input type="number" id="binsize" name="quantity" min="0.001" max="10" value="0.05">
              </div>
                              
              <div class="inputbox">
                <input type="checkbox" id="zoom" value=[-5,3]>
                <label for="zoom">Zoom &nbsp;</label>
              </div>
            </div>
          </form>
        
          <div class="flexcontainer">
            <div class="inputbox" style="width: 40%";>        
              <input type="button" onclick="handleInputChange_histogram(event)" value="LET'S GOOOOO!!!!!"
                style="background-color: #6eb993; border-radius: 10px; color: white; padding: 16px 32px; text-decoration: none; cursor: pointer; width: 100%;">
            </div>   

            <div class="inputbox" style="width: 40%;"> 
              <input type="button" onclick="handleInputChange_PPplot(event)" value="pp plot"
                style="background-color: #6eb993; border-radius: 10px; color: white; padding: 16px 32px; text-decoration: none; cursor: pointer; width: 100%;">
            </div>     
          </div>

          <div class="flexcontainer">
            <div id='histogramChart' class="subchart" style="width: 50%;"></div>
            <div  id="ppDiv" class="subchart" style="width: 40%;"></div>
          </div>

          <div class="flexcontainer">
            <div  id="histogramChartWOdiff" class="subchart" style="width: 45%;"></div>
            <div id='histogramChartSimple' class="subchart" style="width: 45%;"></div>
          </div>
          

        </section>
  
        <section>
          <h2>Logo Replacement</h2>
        </section>
      </article>

      <aside>
        <h4>Backgrounds</h4>
        <p>By nature, the background color on any block element will only show for the length of the content. If you'd like a dividing line instead of a color, place a border on the side of the .content block (but only if it will always contain more content).</p>
      </aside>

      <footer>
        <p> </p>
        <address>
            
        </address>
      </footer>
    </div>      

    <script>
      function toggleSelectBase() {
        var logtransformCheckbox = document.getElementById('logtransform');
        var selectlogbaseContainer = document.getElementById('selectlogbase-container');

        if (logtransformCheckbox.checked) {
          selectlogbaseContainer.style.display = 'block';
        } else {
          selectlogbaseContainer.style.display = 'none';
        }
      };

      function toggleSelectScoring() {
        var ms2rescoreCheckbox = document.getElementById('scoring');

        if (ms2rescoreCheckbox.checked) {
           selectMethodContainer =  document.getElementById("select-ms2rescore-method-container");
           removeMethodContainer = document.getElementById("select-msamanda-method-container");
        } else {
          selectMethodContainer =  document.getElementById("select-msamanda-method-container");
          removeMethodContainer = document.getElementById("select-ms2rescore-method-container");
        };
        selectMethodContainer.style.display = 'block';
        removeMethodContainer.style.display = 'none';
      };

      function getBaseLog(base, value) {
        return Math.log(Number(value)) / Math.log(Number(base));
      }
      
      function processData(data, logTransform, translation, base) {
        var targetScores, decoyScores;

        if (logTransform) {
          decoyScores = data.filter(d => d.is_decoy === "True").map(d => getBaseLog(base, d.score)-translation);
          targetScores = data.filter(d => d.is_decoy === "False").map(d => getBaseLog(base, d.score)-translation);
        } else {
          decoyScores = data.filter(d => d.is_decoy === "True").map(d => Number(d.score));
          targetScores = data.filter(d => d.is_decoy === "False").map(d => Number(d.score));
        }
        return [targetScores, decoyScores];
      };

      function getMinMax(scores) {
        const sortedScores = scores.sort((a,b) => a-b);
        var scoreMin = sortedScores[0];
        var scoreMax = sortedScores[scores.length-1]; 
        return [scoreMin, scoreMax];
      }

      function SubtractHistogramCounts(data1, data2, min, max, numBins, binSize) {

        // Calculate the number of bins
        // var numBins = Math.ceil((max - min) / binSize);

        // Initialize the bin counts array
        let subtractedCounts=[], medScores=[];

        for (let i=0; i < numBins; i++) {
          const binStart = min + i * binSize;
          const binEnd = binStart + binSize;
          subtractedCounts.push(data1.filter(d => d >= binStart && d < binEnd).length - data2.filter(d => d >= binStart && d < binEnd).length);
          medScores.push((binEnd+binStart)/2)

        }

        return [subtractedCounts, medScores];
        }

      
      async function fetchCSV(url) {
        const response = await fetch(url);
        const text = await response.text();
        return text;
      }

      async function handleInputChange_histogram(event) {if (event.type === 'click') {

        const sampleValue = document.getElementById('sample').value;
        // let binSize = document.getElementById('binsize').value;
        var selectionRankValue = document.getElementById('selectrank').value;
        var binsValue = document.getElementById('nr_of_bins').value;
        
        var scoringValue, methodValue, logbaseValue;


        if (document.getElementById('scoring').checked) {
          scoringValue = 'ms2rescore';
          methodValue = document.getElementById('ms2rescoreMethod').value;
          logbaseValue = false;
        } else {
          scoringValue = 'msamanda';
          methodValue = document.getElementById('msamandaMethod').value;
          logbaseValue = document.getElementById('logbase').value;
        }

        console.log('Sample:', sampleValue, "&", 'Scoring:', scoringValue);
        console.log('Method:', methodValue);
        console.log('Number of bins:', binsValue);
        // console.log('Size bins:', binSize);
        console.log('Log base:', logbaseValue, "&", 'selection: ', selectionRankValue);

        try {
          // parse csv data with cutoff scores 
          const cutoffCsvData = await fetchCSV(`./data/cutoff_scores_${selectionRankValue}.csv`);

          const rows_cutoffscores = cutoffCsvData.trim().split('\n').map(row => row.split(','));
          const headers_cutoffscores = rows_cutoffscores[0];
          const data_cutoff_scores = rows_cutoffscores.slice(1).map(row => {
            const obj_cutoff_scores = {};
            headers_cutoffscores.forEach((header, i) => {
              obj_cutoff_scores[header] = row[i];
            });
            return obj_cutoff_scores;
          });

          // parse CSV data w scores
          const filename = `./data/td_scores_${selectionRankValue}/${sampleValue}_${scoringValue}_${methodValue}_scores.csv`;
          console.log(filename);   

          const csvData = await fetchCSV(filename);
          const rows = csvData.trim().split('\n').map(row => row.split(','));
          const headers = rows[0];
          const data = rows.slice(1).map(row => {
            const obj = {};
            headers.forEach((header, i) => {
              obj[header] = row[i];
            });
            return obj;
          });

          const filteredCutoffScores = data_cutoff_scores
            .filter((d) => (d.sample == sampleValue) && (d.method == methodValue) && (d.scoring == scoringValue))[0];

          const logtransformCheckbox = document.getElementById('logtransform');

          var cutoff01, cutoff01, cutoff5, targetScores, decoyScores;

          if ((logtransformCheckbox.checked) && (scoringValue == 'msamanda')) {
            const baseLogValue = document.getElementById('logbase').value;
            const translationValue = getBaseLog(baseLogValue, filteredCutoffScores.pc1);
            
            cutoff01 = getBaseLog(baseLogValue, filteredCutoffScores.pc01) - translationValue;                                
            cutoff1 = getBaseLog(baseLogValue, filteredCutoffScores.pc1) - translationValue;
            cutoff5 = getBaseLog(baseLogValue, filteredCutoffScores.pc5) - translationValue;

            [targetScores, decoyScores] = processData(data, true, translationValue, baseLogValue);
            
            var customXAxisTitle = `log<sub>2</sub>(MSAmanda score)`
          } 
          else {
            cutoff01 = filteredCutoffScores.pc01;
            cutoff1 = filteredCutoffScores.pc1;
            cutoff5 = filteredCutoffScores.pc5;

            [targetScores, decoyScores] = processData(data, false, false, false);

            if (scoringValue == 'msamanda') {
              var customXAxisTitle = 'MSAmanda score'
            } else {
              var customXAxisTitle = 'MS<sup>2</sup>Rescore score'
            }
          }

          console.log('cut-off scores: ', cutoff01, cutoff1, cutoff5);

          var [xMinTargets, xMaxTargets] = getMinMax(targetScores);
          var [xMinDecoys, xMaxDecoys] = getMinMax(decoyScores);

          var zoomCheckbox = document.getElementById('zoom');
          var xMin, xMax;

          
          if ((scoringValue == 'ms2rescore') || (document.getElementById('logtransform').checked)) {
            if (zoomCheckbox.checked) {
              xMin = -4;
              xMax = 4;
            } else {
              xMin = Math.floor(Math.min(xMinDecoys, xMinTargets));
              xMax = Math.ceil(Math.max(xMaxDecoys, xMaxTargets));
            }
          }
          else {
            if (zoomCheckbox.checked) {
              xMin = -20;
              xMax = xMaxDecoys;
            } else {
              xMin = -20;
              xMax = xMaxTargets;
            }
          }

          const xRange = [xMin, xMax];
          var binSize = (xMax-xMin)/binsValue
          
          console.log('xmin targets: ', xMinTargets, ' - ', 'xmax targets: ', xMaxTargets);
          console.log('xmin decoys: ', xMinDecoys, '-' , 'xmax decoys: ', xMaxDecoys);
          console.log('bin size:', binSize);     


          
          // Extract the bin counts from the trace objects
          const [yDataLineChart, xDataLineChart] = SubtractHistogramCounts(targetScores, decoyScores, xMin, xMax, binsValue ,binSize);

          const traceLineChart = {
              x: xDataLineChart,
              y: yDataLineChart,
              name: 'targets-decoys',
              type: 'scatter',
              line: {
                color: 'red',
                width: 2,
                shape: 'spline',
                smoothing: 2.5,
            }};

          console.log(traceLineChart)
        

          const traceDecoys = {
            x: decoyScores,
            name: 'decoys',
            autobinx: false,
            histnorm: "count",
            marker: {
              color: "rgba(255, 100, 102, 0.7)",
              line: {
                color: "rgba(255, 100, 102, 1)",
                width: 1
              }
            },
            opacity: 0.75,
            type: "histogram",
            xbins: {
              end: xMax,
              size: binSize,
              start: xMin
            }
          };
          const traceTargets = {
            x: targetScores,
            autobinx: false,
            histnorm: "count",
            marker: {
              color: "rgba(100, 200, 102, 0.7)",
              line: {
                color: "rgba(100, 200, 102, 1)",
                width: 1
              }
            },
            name: "targets",
            opacity: 0.5,
            type: "histogram",
            xbins: {
              end: xMax,
              size: binSize,
              start: xMin
            }
          };    
          const layout = {
            // autosize: false,
            // width: 560,
            // height: 500,
            margin: {
              l: 50,
              r: 50,
              b: 70,
              t: 150,
              pad: 4
            },
            bargap: 0.05,
            bargroupgap: 0.2,
            barmode: "overlay",
            showlegend: false,
            showlegend: true,
            legend: {
              x: 1,
              xanchor: 'right',
              y: 1.01,
              bordercolor: 'black',
              borderwidth: 0,
              // orientation: 'h',
            },
            xaxis: { 
              title: customXAxisTitle,
              titlefont: {
                  family: 'Arial, sans-serif',
                  size: 18,
                  color: 'grey'
                  },
              range: [xMin, xMax], 
              // range: [-5,3],
              showgrid: false, 
              gridcolor: "#eee",
              griddash: "solid",
              gridwidth: "0.5"
            },
            yaxis: {
              title: {
                text: `Number of PSMs`, 
                standoff: 20,
                },                      
              titlefont: {
                  family: 'Arial, sans-serif',
                  size: 18,
                  color: 'grey'
                  },
              minexponent: 2,
              nticks: 4,
              ticklabelposition: 'inside top',
            },
            title: {
              text: `${sampleValue} ${scoringValue} ${methodValue} - ${selectionRankValue}`,
              font: {
                  family: 'Arial, sans-serif',
                  size: 20,
                  color: 'darkgrey',                
                  },
              x: 0.5,
              y: 5,
              xref: 'paper',
              yref: 'paper',
              xanchor: 'center',
              yanchor: 'top',

              // font: {
              //   family: 'Verdana, sans serif',
              //   size: 20,
              //   color: '#ff7f0e'
              // }
            },              
            shapes: [{
              // type: 'line',
              // x0: cutoff01,
              // y0: 0,
              // x1: cutoff01,
              // y1: 1,
              // yref: 'paper',
              // line: {
              //   color: 'grey',
              //   width: 1,
              //   dash: 'dot'
              // }},
              // {
              type: 'line',
              x0: cutoff1,
              y0: 0,
              x1: cutoff1,
              y1: 1,
              yref: 'paper',
              line: {
                color: 'grey',
                width: 2,
                dash: 'dot'
              }},
            //   {
            //   type: 'line',
            //   x0: cutoff5,
            //   y0: 0,
            //   x1: cutoff5,
            //   y1: 1,
            //   yref: 'paper',
            //   line: {
            //     color: 'grey',
            //     width: 1,
            //     dash: 'dot'
            //   }
            // }
            ],
            annotations: [{
            //   text: `0.1% FDR<br>${Number(cutoff01).toFixed(1)}`,
            //   x: Number(cutoff01) + 0.2,
            //   y: 1.01,
            //   yref: 'paper',
            //   ax: 40,
            //   ay: -40
            // },
            // {
              // text: `1% FDR<br>${Number(0).toFixed(1)}`,
              text: `1% FDR`,
              font: {color: '#6b0000',},
              xanchor: 'bottom',
              x: cutoff1,
              y: 1.07,
              yref: 'paper',
              xref: 'xaxis',
              ax: 40,
              ay: -20,
              showarrow: false,
            // },
            // {
            //   text: `5% FDR<br>${Number(cutoff5).toFixed(1)}`,
            //   x: cutoff5 - 0.2,
            //   y: 1.01,
            //   yref: 'paper',
            //   ax: -40,
            //   ay: -40
            }]
          };
          
          const layoutWOshapes = {
            margin: {
              l: 50,
              r: 50,
              b: 70,
              t: 150,
              pad: 4
            },
            bargap: 0.05,
            bargroupgap: 0.2,
            barmode: "overlay",
            showlegend: false,
            xaxis: { 
              title: customXAxisTitle,
              titlefont: {
                  family: 'Arial, sans-serif',
                  size: 18,
                  color: 'grey'
                  },
              range: [xMin, xMax], 
              // range: [-5,3],
              showgrid: true, 
              gridcolor: "#eee",
              griddash: "solid",
              gridwidth: "0.5",
            },
            yaxis: {
              title: {
                text: `Number of PSMs`, 
                standoff: 20,
                },                      
              titlefont: {
                  family: 'Arial, sans-serif',
                  size: 18,
                  color: 'grey'
                  },
              minexponent: 2,
              nticks: 4,
              ticklabelposition: 'inside top',
              showgrid: true,
            },
            title: {
              text: `${sampleValue} ${scoringValue} ${methodValue} - ${selectionRankValue}`,
              font: {
                  family: 'Arial, sans-serif',
                  size: 20,
                  color: 'darkgrey',                
                  },
              x: 0.5,
              y: 5,
              xref: 'paper',
              yref: 'paper',
              xanchor: 'center',
              yanchor: 'top',

            }}
          
 
            const layoutAllCutoffs = {
              margin: {
              l: 50,
              r: 50,
              b: 70,
              t: 150,
              pad: 4
            },
            bargap: 0.05,
            bargroupgap: 0.2,
            barmode: "overlay",
            showlegend: false,
            xaxis: { 
              title: customXAxisTitle,
              titlefont: {
                  family: 'Arial, sans-serif',
                  size: 18,
                  color: 'grey'
                  },
              range: [xMin, xMax], 
              showgrid: true, 
              gridcolor: "#eee",
              griddash: "solid",
              gridwidth: "0.5"
            },
            yaxis: {
              title: {
                text: `Number of PSMs`, 
                standoff: 20,
                },                      
              titlefont: {
                  family: 'Arial, sans-serif',
                  size: 18,
                  color: 'grey'
                  },
              minexponent: 2,
              nticks: 4,
              ticklabelposition: 'inside top',
            },
            title: {
              text: `${sampleValue} ${scoringValue} ${methodValue} - ${selectionRankValue}`,
              font: {
                  family: 'Arial, sans-serif',
                  size: 20,
                  color: 'darkgrey',                
                  },
              x: 0.5,
              y: 5,
              xref: 'paper',
              yref: 'paper',
              xanchor: 'center',
              yanchor: 'bottom',

            },
            shapes: [{
              type: 'line',
              x0: cutoff01,
              y0: 0,
              x1: cutoff01,
              y1: 1,
              yref: 'paper',
              line: {
                color: 'grey',
                width: 1,
                dash: 'dot'
              }},
              {
              type: 'line',
              x0: cutoff1,
              y0: 0,
              x1: cutoff1,
              y1: 1,
              yref: 'paper',
              line: {
                color: 'grey',
                width: 2,
                dash: 'dot'
              }},
              {
              type: 'line',
              x0: cutoff5,
              y0: 0,
              x1: cutoff5,
              y1: 1,
              yref: 'paper',
              line: {
                color: 'grey',
                width: 1,
                dash: 'dot'
              }
            }
            ],
            annotations: [{
              text: `0.1% FDR<br>${Number(cutoff01).toFixed(1)}`,
              x: Number(cutoff01) + 0.2,
              y: 1.01,
              yref: 'paper',
              ax: 40,
              ay: -40,
              // showarrow: false,
            },
            {
              text: `1% FDR<br>${Number(cutoff1).toFixed(1)}`,
              // text: `1% FDR`,
              font: {color: '#6b0000',},
              // xanchor: 'bottom',
              x: cutoff1,
              y: 1.01,
              yref: 'paper',
              xref: 'xaxis',
              ax: 0,
              ay: -40,
              // showarrow: false,
            },
            {
              text: `5% FDR<br>${Number(cutoff5).toFixed(1)}`,
              x: cutoff5 - 0.2,
              y: 1.01,
              yref: 'paper',
              ax: -40,
              ay: -40
            }]
          };
                     

          histogramChart.fn = `tda_hist_${sampleValue}_${scoringValue}_log${logbaseValue}_${methodValue}_${selectionRankValue}`;
          Plotly.newPlot('histogramChart', [traceDecoys, traceTargets, traceLineChart], layout)
          Plotly.newPlot('histogramChartSimple', [traceDecoys, traceTargets], layout);
          Plotly.newPlot('histogramChartWOdiff', [traceDecoys, traceTargets], layoutAllCutoffs);
          console.log('done');
        } catch (error) {
          console.error('Error fetching CSV:', error);
        }
      }}
    </script>


    <script>

      // Function to fetch CSV data
      async function fetchCSV(url) {
          const response = await fetch(url);
          const text = await response.text();
          return text;
      }


      // Function to handle the input event
      function handleInputChange_PPplot(event) {if (event.type === 'click') {
        // Get the input element that triggered the event
        var sampleValue = document.getElementById('sample').value;
        var selectionRankValue = document.getElementById('selectrank').value;

        if (document.getElementById('scoring').checked) {
          scoringValue = 'ms2rescore';
          methodValue = document.getElementById('ms2rescoreMethod').value;
          // logbaseValue = false;
        } else {
          scoringValue = 'msamanda';
          methodValue = document.getElementById('msamandaMethod').value;
          // logbaseValue = document.getElementById('logbase').value;
        }
        
          
        // Log the updated values for debugging purposes
        console.log('Sample:', sampleValue);
        console.log('Scoring:', scoringValue);
        console.log('Method:', methodValue);
        console.log('selection: ', selectionRankValue)

        // Update the filename and fetch the CSV data
        var filename = `./data/pp_info_${selectionRankValue}.csv`;
        console.log(filename);

        const csvURL = filename;
        fetchCSV(csvURL)
          .then(csvData => {
            // Parse CSV data
            const rows = csvData.trim().split('\n').map(row => row.split('\t'));

            // Extract header row
            const headers = rows[0];

            // Create array of objects representing CSV data
            var data2 = rows.slice(1).map(row => {
                const obj = {};
                headers.forEach((header, i) => {
                    obj[header] = row[i];
                });
                return obj;
            });

            console.log(data2);

            filteredData = data2.filter((d) => d.sample == sampleValue)
              .filter((d) => d.scoring == scoringValue)
              .filter((d) => d.method == methodValue);
      
            console.log(filteredData);

            var targetScores = filteredData[0].targets;
            var cdf_targets = targetScores.substring(1, targetScores.length - 1).split(', ').map((d) => Number(d))

            var decoyScores = filteredData[0].decoys;
            var cdf_decoys = decoyScores.substring(1, decoyScores.length - 1).split(', ').map((d) => Number(d))                 
            
            var trace1 = {
              x: cdf_decoys,
              y: cdf_targets,
              type: 'scatter',
              color: '#6996c6',
              zorder: 1
            };

            var trace2 = {
              x: [0, 1],
              y: [0, filteredData[0].slope],
              name: 'pi0',
              type: 'scatter',
              mode: 'lines',   
              opacity: 0.75,
              line: {
                color: '#f28e2c',
                width: 5
              },
              zorder:0
            };

            var datab = [trace1, trace2];

            var layout = {
              showlegend: false,
              // showlegend: true,
              // autosize: false,
              // width: 660,
              // height: 500,
              margin: {
                l: 70,
                r: 50,
                b: 70,
                t: 100,
                pad: 4
              },
              title: `PP plot<br> ${sampleValue} ${scoringValue} ${methodValue} ${selectionRankValue}`, 
              xaxis: {
                title: "Fdp",
                titlefont: {
                  family: 'Arial, sans-serif',
                  size: 18,
                  color: 'grey'
                },
                range: [0, 1.01]
              }, 
              yaxis: {
                title: "Ftp",
                titlefont: {
                  family: 'Arial, sans-serif',
                  size: 18,
                  color: 'grey'
                },
                range: [0, 1.01]
              }, 
            };
            ppDiv.fn = `pp_plot_${sampleValue}_${scoringValue}_${methodValue}_${selectionRankValue}`;
            Plotly.newPlot('ppDiv', datab, layout);
          })
          .catch(error => console.error('Error fetching CSV:', error));
      }}
    </script>
          


  </body>
</html>